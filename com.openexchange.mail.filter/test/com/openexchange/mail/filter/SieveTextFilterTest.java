/*
* @copyright Copyright (c) OX Software GmbH, Germany <info@open-xchange.com>
* @license AGPL-3.0
*
* This code is free software: you can redistribute it and/or modify
* it under the terms of the GNU Affero General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU Affero General Public License for more details.
*
* You should have received a copy of the GNU Affero General Public License
* along with OX App Suite.  If not, see <https://www.gnu.org/licenses/agpl-3.0.txt>.
* 
* Any use of the work other than as authorized under this license or copyright law is prohibited.
*
*/

package com.openexchange.mail.filter;

import static org.junit.jupiter.api.Assertions.assertEquals;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.time.Instant;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import org.junit.Test;
import com.openexchange.java.Strings;
import com.openexchange.jsieve.commands.RuleComment;
import com.openexchange.jsieve.export.SieveTextFilter;
import com.openexchange.mailfilter.Credentials;

/**
 * {@link SieveTextFilterTest}
 *
 * @author <a href="mailto:ioannis.chouklis@open-xchange.com">Ioannis Chouklis</a>
 */
class SieveTextFilterTest {

    private static final String SCRIPT = """
        # Generated by OX Sieve Bundle on 2023-07-26T09:09:56Z
        require [ "envelope" , "vacation" ];

        ## Flag: vacation|UniqueId:6|Rulename: vacation notice|LastModified: 2023-07-26T12:08:32Z|ModifiedBy: 172.18.0.4
        if true
        {
        vacation :days 7 :addresses "anton@context1.ox.test" :subject "dfdfsgdsasdf" "gdsdf

        dsfgg
        fdg
        fdg
        fdgsfd

        " ;
        }

        ## Flag: |UniqueId:0|Rulename: rule1|LastModified: 2023-07-26T08:07:34Z|ModifiedBy: 172.18.0.1
        if header :contains [ "List-Id" , "X-BeenThere" , "X-Mailinglist" , "X-Mailing-List" ] "asdf"
        {
        keep ;
        }

        ## Flag: |UniqueId:1|Rulename: rule 2 updated
        if envelope :is :all "to" "dsf"
        {
        keep ;
        }

        ## Flag: |UniqueId:2|Rulename: rule 3|LastModified: 2023-07-26T08:13:37Z|ModifiedBy: 172.18.0.2
        if header :contains "Subject" "erw"
        {
        discard ;
        }

        ## Flag: |UniqueId:3|Rulename: rule 4 with new structure|LastModified: 2023-07-26T09:09:56Z|ModifiedBy: 172.18.0.3
        if header :contains "Subject" "asdf"
        {
        discard ;
        }
                """;

    private static final String FLAG = "flag";
    private static final String ID = "id";
    private static final String NAME = "name";
    private static final String LAST_MODIFIED = "last-modified";
    private static final String MODIFIED_BY = "modified-by";

    /**
     * Tests that the metadata lines are correctly parsed from the getMetadata method in SieveTextFilter.
     */
    @SuppressWarnings("unchecked")
    @Test
    void testGetMetadata() throws NoSuchMethodException, SecurityException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
        //@formatter:off
        List<Map<String, String>> expected = List.of(
            Map.of(FLAG, "vacation", ID, "6", NAME, "vacation notice", LAST_MODIFIED, "2023-07-26T12:08:32Z", MODIFIED_BY, "172.18.0.4"), 
            Map.of(FLAG, "", ID, "0", NAME, "rule1", LAST_MODIFIED, "2023-07-26T08:07:34Z", MODIFIED_BY, "172.18.0.1"), 
            Map.of(FLAG, "", ID, "1", NAME, "rule 2 updated"), 
            Map.of(FLAG, "", ID, "2", NAME, "rule 3", LAST_MODIFIED, "2023-07-26T08:13:37Z", MODIFIED_BY, "172.18.0.2"), 
            Map.of(FLAG, "", ID, "3", NAME, "rule 4 with new structure", LAST_MODIFIED, "2023-07-26T09:09:56Z", MODIFIED_BY, "172.18.0.3"));
        //@formatter:on
        Credentials creds = new Credentials("testGetRulename", "testGetRulename", 1138, 31145);
        SieveTextFilter sieve = new SieveTextFilter(creds);
        Method metadataMethod = SieveTextFilter.class.getDeclaredMethod("getMetadata", String.class);
        metadataMethod.setAccessible(true);
        ArrayList<RuleComment> metadata = (ArrayList<RuleComment>) metadataMethod.invoke(sieve, SCRIPT);
        assertEquals(5, metadata.size());
        int i = 0;
        for (RuleComment ruleComment : metadata) {
            Map<String, String> map = expected.get(i++);
            String flag = map.get(FLAG);
            if (Strings.isNotEmpty(flag)) {
                List<String> flags = ruleComment.getFlags();
                assertEquals(1, flags.size());
                assertEquals(flag, Strings.toCommaSeparatedList(flags.toArray(new String[] {})));
            }
            assertEquals(Integer.parseInt(map.get(ID)), ruleComment.getUniqueId());
            assertEquals(map.get(NAME), ruleComment.getRulename());
            String lastModified = map.get(LAST_MODIFIED);
            if (Strings.isNotEmpty(lastModified)) {
                assertEquals(Instant.parse(map.get(LAST_MODIFIED)).toEpochMilli(), ruleComment.getUpdateTimestamp());
                assertEquals(map.get(MODIFIED_BY), ruleComment.getSourceOfUpdate());
            }
        }
    }
}
